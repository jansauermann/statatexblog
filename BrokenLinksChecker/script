const BASE_URL = "https://your.page.com/";  // Change this
const EMAIL = "YOUR_EMAIL_ADDRESS";  // Change this

function checkBrokenLinks() {
  const visited = new Set();
  const toVisit = [BASE_URL];
  const brokenLinks = [];

  Logger.clear();

  while (toVisit.length > 0) {
    const rawUrl = toVisit.pop();
    const pageUrl = normalizeUrl(rawUrl);

    if (visited.has(pageUrl)) continue;
    visited.add(pageUrl);

    Logger.log(`Visiting: ${pageUrl}`);

    let html;
    try {
      html = UrlFetchApp.fetch(pageUrl).getContentText();
    } catch (e) {
      Logger.log(`Failed to fetch ${pageUrl}: ${e}`);
      brokenLinks.push({ page: pageUrl, link: pageUrl, text: "(page fetch failed)", code: "ERROR" });
      continue;
    }

    html = html.replace(/```{=html}[\s\S]*?```/g, '');

    const regex = /<a\s+(?:[^>]*?\s+)?href="([^"]+)"[^>]*?>(.*?)<\/a>/gi;
    let match;

    while ((match = regex.exec(html)) !== null) {
      const href = match[1].trim();
      const text = match[2].replace(/\s+/g, ' ').trim();

      if (href.startsWith("mailto:") || href.startsWith("javascript:") || href.startsWith("#")) continue;

      let fullUrl;
      try {
        fullUrl = resolveRelativeUrl(href, pageUrl);
      } catch (e) {
        brokenLinks.push({ page: pageUrl, link: href, text, code: "ERROR (invalid relative URL)" });
        continue;
      }

      const normalizedLink = normalizeUrl(fullUrl);
      const linkWithoutFragment = normalizedLink.split("#")[0];

      const isInternal = linkWithoutFragment.startsWith(BASE_URL);

      if (isInternal && !visited.has(linkWithoutFragment) && !toVisit.includes(linkWithoutFragment)) {
        toVisit.push(linkWithoutFragment);
      }

      try {
        const response = UrlFetchApp.fetch(linkWithoutFragment, { muteHttpExceptions: true });
        const code = response.getResponseCode();
        Logger.log(`Checked: ${linkWithoutFragment} ‚Üí ${code}`);
        if (code !== 200 && code !== 999 && code !== 403) {
          brokenLinks.push({ page: pageUrl, link: linkWithoutFragment, text, code });
        }
      } catch (e) {
        Logger.log(`Error fetching ${linkWithoutFragment}: ${e}`);
        brokenLinks.push({ page: pageUrl, link: linkWithoutFragment, text, code: "ERROR" });
      }
    }
  }

  if (brokenLinks.length > 0) {
    const body = brokenLinks.map(b =>
      `üîó On page: ${b.page}\n‚Üí Link: ${b.link}\n‚Üí Text: "${b.text}"\n‚Üí Status: ${b.code}`
    ).join("\n\n");

    MailApp.sendEmail({
      to: EMAIL,
      subject: "üîç Broken links found on your Quarto site",
      body: `The following broken links were detected:\n\n${body}`,
    });

    Logger.log("Email sent with broken links.");
  } else {
    Logger.log("No broken links found.");
  }
}

function normalizeUrl(url) {
  if (url.endsWith('/') && url !== BASE_URL + '/') {
    url = url.slice(0, -1);
  }
  url = url.replace(/\/index\.html$/, '');
  url = url.replace(/([^:]\/)\/+/g, '$1');
  return url;
}

function resolveRelativeUrl(href, baseUrl) {
  if (href.startsWith("http")) return href;

  const baseMatch = baseUrl.match(/^(https?:\/\/[^\/]+)(\/.*)?$/);
  if (!baseMatch) throw new Error("Invalid base URL");

  const origin = baseMatch[1];
  let path = baseMatch[2] || "/";

  if (path.match(/\/[^\/]+\.html$/)) {
    path = path.substring(0, path.lastIndexOf("/")) + "/";
  }

  if (href.startsWith("/")) {
    return origin + href;
  }

  const combined = path + href;
  const segments = combined.split("/");
  const resolved = [];

  for (const segment of segments) {
    if (segment === "..") {
      resolved.pop();
    } else if (segment !== "." && segment !== "") {
      resolved.push(segment);
    }
  }

  return origin + "/" + resolved.join("/");
}
