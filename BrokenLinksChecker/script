const BASE_URL = "https://your.page.com/";  // Change this
const EMAIL = "YOUR_EMAIL_ADDRESS";  // Change this


const OK_STATUSES = new Set([200, 301, 302, 303, 307, 308, 401, 403, 999]);

function checkBrokenLinks() {
  const base = ensureTrailingSlash(BASE_URL);

  const visitedPages = new Set();
  const toVisit = [base];
  const broken = [];

  Logger.clear();

  while (toVisit.length > 0) {
    const current = toVisit.pop();
    const pageUrl = canonicalUrl(current, true);

    if (visitedPages.has(pageUrl)) continue;
    visitedPages.add(pageUrl);

    Logger.log(`Visiting: ${pageUrl}`);

    let html, contentType;
    try {
      const resp = UrlFetchApp.fetch(pageUrl, {
        followRedirects: true,
        muteHttpExceptions: true,
        headers: { "User-Agent": "AppsScript LinkChecker/1.0" },
      });
      const code = resp.getResponseCode();
      contentType = resp.getHeaders()["Content-Type"] || "";

      if (!OK_STATUSES.has(code)) {
        broken.push({ page: pageUrl, link: pageUrl, text: "(page fetch failed)", code });
        continue;
      }

      if (!/text\/html/i.test(contentType)) continue;
      html = resp.getContentText();

    } catch (e) {
      broken.push({ page: pageUrl, link: pageUrl, text: "(page fetch error)", code: "ERROR" });
      continue;
    }

    html = html.replace(/```{=html}[\s\S]*?```/g, "");
    html = html.replace(/<code[\s\S]*?<\/code>/gi, "");
    html = html.replace(/<pre[\s\S]*?<\/pre>/gi, "");

    const regex = /<a\s+(?:[^>]*?\s+)?href="([^"]+)"[^>]*?>(.*?)<\/a>/gi;
    let match;

    while ((match = regex.exec(html)) !== null) {
      const rawHref = sanitizeHref(match[1]);
      const linkText = stripHtml(match[2]).replace(/\s+/g, " ").trim();
      if (!rawHref || /^(mailto:|javascript:|tel:|#)/i.test(rawHref)) continue;

      let resolved;
      try {
        resolved = resolveRelativeUrl(rawHref, pageUrl);
      } catch (e) {
        broken.push({ page: pageUrl, link: rawHref, text: linkText, code: "ERROR (invalid URL)" });
        continue;
      }

      let normalized = canonicalUrl(resolved, true);
      const isInternal = normalized.startsWith(base);

      if (isInternal && /\.(qmd|md)$/i.test(normalized)) {
        normalized = normalized.replace(/\.(qmd|md)$/i, ".html");
      }

      if (isInternal && looksLikeHtmlPage(normalized) &&
          !visitedPages.has(normalized) && !toVisit.includes(normalized)) {
        toVisit.push(normalized);
      }

      try {
        const resp = UrlFetchApp.fetch(normalized, {
          followRedirects: true,
          muteHttpExceptions: true,
          headers: { "User-Agent": "AppsScript LinkChecker/1.0" },
        });
        const code = resp.getResponseCode();
        Logger.log(`Checked: ${normalized} ‚Üí ${code}`);
        if (!OK_STATUSES.has(code)) {
          broken.push({ page: pageUrl, link: normalized, text: linkText, code });
        }
      } catch (e) {
        broken.push({ page: pageUrl, link: normalized, text: linkText, code: "ERROR" });
      }
    }
  }

  if (broken.length > 0) {
    const body = broken.map(b =>
      `üîó On page: ${b.page}\n‚Üí Link: ${b.link}\n‚Üí Text: "${b.text}"\n‚Üí Status: ${b.code}`
    ).join("\n\n");

    MailApp.sendEmail({
      to: EMAIL,
      subject: "üîç Broken links found on your Quarto site",
      body: `The following broken links were detected:\n\n${body}`,
    });
  } else {
    Logger.log("No broken links found.");
  }
}

/** Helpers **/

function ensureTrailingSlash(u) {
  return u.endsWith("/") ? u : u + "/";
}

function canonicalUrl(href, stripHash) {
  let url = href;
  if (stripHash) url = url.split("#")[0];

  url = url.replace(/\/index\.html$/i, "/");
  url = url.replace(/([^:]\/)\/+/g, "$1");

  // fix: ta bort punkt som st√•r f√∂re slash
  url = url.replace(/\.(?=\/)/g, "");
  // fix: ta bort om path slutar med "/."
  url = url.replace(/\/\.$/, "/");

  url = url.replace(/[.;]+$/g, "");
  return url;
}

function looksLikeHtmlPage(url) {
  if (url.endsWith("/")) return true;
  if (url.match(/\.html?$/i)) return true;
  const last = url.split("/").pop();
  if (last && !last.includes(".")) return true;
  return false;
}

function sanitizeHref(href) {
  if (!href) return href;
  return href.trim().replace(/([)\].,;:]+)$/g, "");
}

function stripHtml(s) {
  return s.replace(/<[^>]*>/g, "");
}

function resolveRelativeUrl(href, baseUrl) {
  if (/^https?:\/\//i.test(href)) return href;

  const baseMatch = baseUrl.match(/^(https?:\/\/[^\/]+)(\/.*)?$/);
  if (!baseMatch) throw new Error("Invalid base URL");

  const origin = baseMatch[1];
  let path = baseMatch[2] || "/";

  if (!path.endsWith("/")) {
    const idx = path.lastIndexOf("/");
    path = idx >= 0 ? path.slice(0, idx + 1) : "/";
  }

  if (href.startsWith("/")) {
    return origin + canonicalUrl(href, true);
  }

  const combined = path + href;
  const segments = combined.split("/");
  const resolved = [];

  for (const seg of segments) {
    if (seg === "..") {
      if (resolved.length > 0) resolved.pop();
    } else if (seg === "." || seg === "") {
      // skip
    } else {
      resolved.push(seg);
    }
  }

  let abs = origin + "/" + resolved.join("/");

  abs = abs.replace(/\.(?=\/)/g, "");
  abs = abs.replace(/\/\.$/, "/");

  return canonicalUrl(abs, true);
}
